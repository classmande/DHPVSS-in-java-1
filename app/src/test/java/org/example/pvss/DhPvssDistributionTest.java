package org.example.pvss;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import org.bouncycastle.math.ec.ECPoint;
import org.junit.Test;

public class DhPvssDistributionTest {

    /**
     * Test that distribute() correctly encrypts each share via C_i = A_i + sk_D*E_i
     * 
     * @throws NoSuchAlgorithmException
     */
    @Test
    public void testDistributeCorrectlyEncryptsShares() throws NoSuchAlgorithmException {
        // Setup parameters
        int t = 2, n = 5;
        GroupGenerator.GroupParameters gp = GroupGenerator.generateGroup();
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(gp, t, n);

        // Dealer key pair and secret S = G * s
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        BigInteger s = dealer.getSecretKey().mod(ctx.getOrder());
        ECPoint S = ctx.getGenerator().multiply(s);

        DhKeyPair[] ephKeyPairs = new DhKeyPair[n];
        EphemeralKeyPublic[] epkWrapped = new EphemeralKeyPublic[n];
        for (int i = 0; i < n; i++) {
            DhKeyPair kp = DhKeyPair.generate(ctx);
            ephKeyPairs[i] = kp;
            NizkDlProof proof = NizkDlProof.generateProof(ctx, kp);
            epkWrapped[i] = new EphemeralKeyPublic(kp.getPublic(), proof);
        }

        // Compute the plaintext shares A_i
        ECPoint[] A = GShamir_Share.generateSharesEC(ctx, S);

        // Call distribution
        DHPVSS_Dist.DistributionResult result = DHPVSS_Dist.distribute(
                ctx, epkWrapped, dealer, S);
        ECPoint[] C = result.getEncryptedShares();

        // Re‐extract the Eᵢ’s
        ECPoint[] E = new ECPoint[n];
        for (int i = 0; i < n; i++) {
            E[i] = epkWrapped[i].getPublicKey();
        }

        BigInteger skD = dealer.getSecretKey().mod(ctx.getOrder());

        // 1) Decrypt each C[i] to recover the Shamir–share Aᵢ = Cᵢ − sk_D⋅Eᵢ
        ECPoint[] recoveredA = new ECPoint[n];
        for (int i = 0; i < n; i++) {
            ECPoint mask = E[i].multiply(skD).normalize();
            recoveredA[i] = C[i].subtract(mask).normalize();
        }

        // 2) Reconstruct S from any t+1 of those Aᵢ’s
        // here we just pick the first t+1 indices: {1,2,…,t+1}
        int[] subsetIdx = new int[t + 1];
        for (int i = 0; i < t + 1; i++)
            subsetIdx[i] = i + 1; // 1‐based
        ECPoint[] subsetShares = new ECPoint[t + 1];
        for (int i = 0; i < t + 1; i++)
            subsetShares[i] = recoveredA[i];

        ECPoint recS = GShamir_Share.reconstructSecretEC(ctx, subsetShares, subsetIdx);

        // 3) Assert that we got exactly the original S back
        assertEquals("Reconstructed secret must match original S", S, recS);
    }

    /**
     * Test that the DLEQ proof generated by distribute() verifies correctly,
     * and that tampering with one share makes it fail.
     * 
     * @throws NoSuchAlgorithmException
     */
    @Test
    public void testDleqProofWithAndWithoutTampering() throws NoSuchAlgorithmException {
        int t = 2, n = 5;
        GroupGenerator.GroupParameters gp = GroupGenerator.generateGroup();
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(gp, t, n);
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        BigInteger s = dealer.getSecretKey().mod(ctx.getOrder());
        ECPoint S = ctx.getGenerator().multiply(s);

        // Ephemeral keys
        DhKeyPair[] ephKeyPairs = new DhKeyPair[n];
        EphemeralKeyPublic[] epkWrapped = new EphemeralKeyPublic[n];
        for (int i = 0; i < n; i++) {
            DhKeyPair kp = DhKeyPair.generate(ctx);
            ephKeyPairs[i] = kp;
            NizkDlProof proof = NizkDlProof.generateProof(ctx, kp);
            epkWrapped[i] = new EphemeralKeyPublic(kp.getPublic(), proof);
        }
        ECPoint[] E = new ECPoint[n];
        for (int i = 0; i < n; i++) {
            E[i] = epkWrapped[i].getPublicKey();
        }

        // Distribute
        DHPVSS_Dist.DistributionResult dr = DHPVSS_Dist.distribute(
                ctx, epkWrapped, dealer, S);
        ECPoint[] C = dr.getEncryptedShares();
        NizkDlEqProof proof = dr.getDleqProof();

        // Recompute U, V exactly as in distribute()
        BigInteger p = ctx.getOrder();
        int numCoeffs = n - t - 1;

        BigInteger[] poly = HashingTools.hashPointsToPoly(
                dealer.getPublic(), E, C, numCoeffs, p);
        BigInteger[] alphas = ctx.getAlphas();
        BigInteger[] evals = new BigInteger[n + 1];
        for (int i = 1; i <= n; i++) {
            evals[i] = EvaluationTools.evaluatePolynomial(
                    poly, alphas[i], p);
        }
        BigInteger[] v = ctx.getV();
        ECPoint U = ctx.getGenerator().getCurve().getInfinity();
        ECPoint V = ctx.getGenerator().getCurve().getInfinity();
        for (int i = 1; i <= n; i++) {
            BigInteger r = evals[i].multiply(v[i - 1]).mod(p);
            U = U.add(E[i - 1].multiply(r)).normalize();
            V = V.add(C[i - 1].multiply(r)).normalize();
        }

        // The proof should verify for the correct U,V
        assertTrue(
                "DLEQ proof must verify on untampered data",
                NizkDlEqProof.verifyProof(ctx, U, dealer.getPublic(), V, proof));

        // Tamper one C_i and recompute V
        ECPoint[] Cbad = Arrays.copyOf(C, n);
        Cbad[2] = Cbad[2].add(ctx.getGenerator());
        ECPoint Vbad = ctx.getGenerator().getCurve().getInfinity();
        for (int i = 1; i <= n; i++) {
            BigInteger r = evals[i].multiply(v[i - 1]).mod(p);
            Vbad = Vbad.add(Cbad[i - 1].multiply(r)).normalize();
        }
        // Proof must fail on tampered V
        assertFalse(
                "DLEQ proof must fail when shares are tampered",
                NizkDlEqProof.verifyProof(ctx, U, dealer.getPublic(), Vbad, proof));
    }

    /**
     * Test that providing the wrong number of ephemeral keys triggers an exception.
     */
    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void testDistributionWrongEphemeralLength() {
        int t = 2, n = 5;
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(
                GroupGenerator.generateGroup(), t, n);
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        ECPoint S = ctx.getGenerator().multiply(
                dealer.getSecretKey().mod(ctx.getOrder()));
        EphemeralKeyPublic[] wrongE = new EphemeralKeyPublic[n - 1]; // too short
        DHPVSS_Dist.distribute(ctx, wrongE, dealer, S);
    }
}
