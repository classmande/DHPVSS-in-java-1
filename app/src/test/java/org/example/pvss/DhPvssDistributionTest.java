package org.example.pvss;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.math.BigInteger;

import org.bouncycastle.math.ec.ECPoint;
import org.junit.Test;

public class DHPVSSDistributionTest {

    /**
     * Test that distribute() correctly encrypts each share via C_i = A_i + sk_D*E_i
     */
    @Test
    public void testDistributeCorrectlyEncryptsShares() {
        // Setup parameters
        int t = 2, n = 5;
        GroupGenerator.GroupParameters gp = GroupGenerator.generateGroup();
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(gp, t, n);

        // Dealer key pair and secret S = G * s
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        BigInteger s = dealer.getSecretKey().mod(ctx.getOrder());
        ECPoint S = ctx.getGenerator().multiply(s);

        // Generate ephemeral key pairs for participants
        DhKeyPair[] ephKeys = new DhKeyPair[n];
        ECPoint[] E = new ECPoint[n];
        for (int i = 0; i < n; i++) {
            ephKeys[i] = DhKeyPair.generate(ctx);
            E[i] = ephKeys[i].getPublicKey();
        }

        // Compute the plaintext shares A_i
        ECPoint[] A = GShamir_Share.generateSharesEC(ctx, S);

        // Call distribution
        DHPVSS_Dist.DistributionResult result = DHPVSS_Dist.distribute(
            ctx, E, dealer, S
        );
        ECPoint[] C = result.getEncryptedShares();

        // Assert lengths
        assertEquals("EncryptedShares length", n, C.length);

        // Check each C_i = A_i + sk_D * E_i
        BigInteger skD = dealer.getSecretKey();
        for (int i = 0; i < n; i++) {
            ECPoint mask = E[i].multiply(skD).normalize();
            ECPoint expected = A[i].add(mask).normalize();
            assertEquals("Encrypted share mismatch at index " + i,
                         expected, C[i]);
        }
    }

    /**
     * Test that the DLEQ proof generated by distribute() verifies correctly,
     * and that tampering with one share makes it fail.
     */
    @Test
    public void testDleqProofWithAndWithoutTampering() {
        int t = 2, n = 5;
        GroupGenerator.GroupParameters gp = GroupGenerator.generateGroup();
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(gp, t, n);
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        BigInteger s = dealer.getSecretKey().mod(ctx.getOrder());
        ECPoint S = ctx.getGenerator().multiply(s);

        // Ephemeral keys
        DhKeyPair[] eph = new DhKeyPair[n];
        ECPoint[] E = new ECPoint[n];
        for (int i = 0; i < n; i++) {
            eph[i] = DhKeyPair.generate(ctx);
            E[i] = eph[i].getPublicKey();
        }

        // Distribute
        DHPVSS_Dist.DistributionResult dr = DHPVSS_Dist.distribute(
            ctx, E, dealer, S
        );
        ECPoint[] C = dr.getEncryptedShares();
        NizkDlEqProof proof = dr.getDleqProof();

        // Recompute U, V exactly as in distribute()
        BigInteger p = ctx.getOrder();
        int numCoeffs = n - t - 1;
        BigInteger[] poly = HashingTools.hashPointsToPoly(
            dealer.getPublicKey(), E, C, numCoeffs, p
        );
        BigInteger[] alphas = ctx.getAlphas();
        BigInteger[] evals = new BigInteger[n+1];
        for (int i = 1; i <= n; i++) {
            evals[i] = EvaluationTools.evaluatePolynomial(
                poly, alphas[i], p
            );
        }
        BigInteger[] v = ctx.getV();
        ECPoint U = ctx.getGenerator().getCurve().getInfinity();
        ECPoint V = ctx.getGenerator().getCurve().getInfinity();
        for (int i = 1; i <= n; i++) {
            BigInteger r = evals[i].multiply(v[i-1]).mod(p);
            U = U.add(E[i-1].multiply(r)).normalize();
            V = V.add(C[i-1].multiply(r)).normalize();
        }

        // The proof should verify for the correct U,V
        assertTrue(
            "DLEQ proof must verify on untampered data",
            NizkDlEqProof.verifyProof(ctx, U, dealer.getPublicKey(), V, proof)
        );

        // Tamper one C_i and recompute V
        ECPoint[] Cbad = Arrays.copyOf(C, n);
        Cbad[2] = Cbad[2].add(ctx.getGenerator());
        ECPoint Vbad = ctx.getGenerator().getCurve().getInfinity();
        for (int i = 1; i <= n; i++) {
            BigInteger r = evals[i].multiply(v[i-1]).mod(p);
            Vbad = Vbad.add(Cbad[i-1].multiply(r)).normalize();
        }
        // Proof must fail on tampered V
        assertFalse(
            "DLEQ proof must fail when shares are tampered",
            NizkDlEqProof.verifyProof(ctx, U, dealer.getPublicKey(), Vbad, proof)
        );
    }

    /**
     * Test that providing the wrong number of ephemeral keys triggers an exception.
     */
    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void testDistributionWrongEphemeralLength() {
        int t = 2, n = 5;
        DhPvssContext ctx = DHPVSS_Setup.dhPvssSetup(
            GroupGenerator.generateGroup(), t, n
        );
        DhKeyPair dealer = DhKeyPair.generate(ctx);
        ECPoint S = ctx.getGenerator().multiply(
            dealer.getSecretKey().mod(ctx.getOrder())
        );
        ECPoint[] wrongE = new ECPoint[n-1]; // too short
        DHPVSS_Dist.distribute(ctx, wrongE, dealer, S);
    }
}
